\section{Упорядочение сообщений. Определения, иерархия порядков. Алгоритм для причинно-согласованного порядка.}

\begin{definition}
    Говорят, что соблюдается \textit{причинно-согласованный порядок}, если
    \[
        \not \exists m,n \in \bM \colon~ \texttt{snd(m)} \rightarrow \texttt{snd(n)}
        \wedge \texttt{rcv(n)} \rightarrow \texttt{rcv(m)}
    .\]
\end{definition}

\begin{remark}
    Под $\to$ подразумевается отношение ``произошло до``.
\end{remark}

\begin{algorithm}(Централизованный алгоритм для причинно-согласованного порядка)

    Выберем координатора, который будет осуществлять передачу. Для корректности алгоритма достаточно, чтобы каналы до координатора имели FIFO порядок.
\end{algorithm}

\begin{algorithm}(Распределенный алгоритм для причинно-согласованного порядка)

    \begin{itemize}
        \item Используем матричные часы:
        \begin{itemize}
            \item У каждого процесса хранится матрица $M$. $M_{ij}$ -- количество сообщений, посланных от процесса $P_i$ к процессу $P_j$.
            \item Перед посылкой сообщения от $P_i$ к $P_j$ обновляем $M_{ij} = M_{ij} + 1$ и шлем матрицу $M$ вместе с сообщением.
        \end{itemize}
        \item Сообщение от $P_i$ к $P_j$ с матрицей $W$ обрабатывается, если выполнены все условия:
        \begin{itemize}
            \item Соблюдается FIFO порядок: $W_{ji} = M_{ji} + 1$. Сообщение имеет ожидаемый номер.
            \item Соблюдается причинная согласованность: $\forall k \not = j \colon~ M_{ki} \geqslant W_{ji}$. То есть посылающий процесс не знает о событиях, о которых не знает принимающий.
            \item После обработки обновляем матрицу: $M = \max{(M, W)}$.
        \end{itemize}
        \item При невыполнении хотя бы одного из условий сообщение кладется в очередь.
    \end{itemize}

\end{algorithm}

\begin{remark}
    Причинно-согласованный порядок сильнее, чем FIFO порядок.
\end{remark}
