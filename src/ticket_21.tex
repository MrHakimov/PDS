\section{Иерархия ошибок в распределенных системах. Отказ узла в асинхронной системе --- невозможность консенсуса (доказательство Фишера-Линча-Патерсона).}


\begin{algorithm}(Иерархия ошибок и отказов в распределенных системах)
    1) отказ узла (самый простой)
    2) отказ канала (равносильно отказу всех узлов)
    3) ненадежная доставка (некоторые сообщения доходят)
    4) Византийская ошибка (враги захватили узел и пытаются тебя поиметь)
\end{algorithm}

Стоит отметить, что именно они делают программирование распределенных систем довольно сложным, так как являются нормой. При частичном отказе системы остальные части должны продолжать работать. 

Для корректного решения частичного отказа стоит сначала определить виды систем
1) Синхронные системы 
1.1) время передачи сообщения ограничено сверху
1.2) можно разбить выполнение алгоритма на фазы
2) Асинхронные системы
2.1) время не ограничено
2.2) время передачи конечно, если нет отказов

Рассмотрим свойства консенсуса в распределнной системе:
1) Согласие - Все процессы должны завершиться с одним и тем же решением.
2) Нетривиальность - Должны быть варианты исполнения, приводящие к разным решениям.
3) Обоснованность - Решение должно быть предложением одного из процессов.
4) Завершение - Протокол должен завершиться за конечное время.

Достичь этих свойств без отказа легко:
1) Каждый процесс шлет свое предложение вем остальных.
2) Дожидается предложение от других процессов.
3) Теперь из данных предложений, используя детерминированную функцию (max, min, etc), выбирает решение

Этот алгоритм работает и в асинхронной системе.

КЛЮЧЕВАЯ ТЕОРЕМА КУРСА (Фишера-Линча-Патерсона)
Не существует такого детерминированного алгоритма, который при любом исполнении за конечное время придет к консенсусу.

Доказательство (от противного)
Допустим такой алгоритм существует, тогда рассмотрим его исполнении на множестве из 0 и 1.
Модель системы для теоремы:
Процесс - это некоторый детерминированный автомат, который может делать 3 функции:
1) Указать ожидать получения сообщения (нет возможности указать время ожидания)
2) Отправить сообщение
3) Принять решение (можно только 1 раз это сделать, но при этом сообщать свое решение другим алгоритмам решено)
Конфигурация - состояние всех процессов + сообщения в пути (отправленные + неполученные)
Шагом в такой конфигурации называется 
1) обработка какого-то сообщения процессом
2) внутреннее действие этого процесса и посылка им от нуля до нескольких сообщений до тех пор, пока процесс не перейдет к ожиданию следующего сообщения.
Так как все операции детерминированы, можно нарисовать полное дерево переходов.
Начальная конфигурация содержит начальные данные для каждого из процессов.
1) может содержать сколько угодно входных данных
2) начальных конфигураций много (на каждый вариант входных данных)
3) Каждый процесс может иметь свою программу
Исполнение - бесконечная цепочка шагов от начального состояния, так как процессы продолжают выполняться и после принятия решения.
Отказ - процесс, который делает конечное число шагов в процессе исполнения.
Надежная доставка - любое сообщение неотказавшего процесса обрабатывается за конечное число шагов.
Согласие и решение - все процессы должны прийти к решению за конечное число шагов (кроме возможно отказавшего)
Валентность
Конфигурация i-валентная, если все цепочки шагов приводят к решению i
бивалентная если есть цепочки, приводящие к 0, и цепочки, приводящие к 1.
Коммутирующие события - это цепочки с событиями на разных процессах, которые приводят к одной и той же конфигурации, при изменении порядка их исполнения.

Лемма 1. Существует начальная бивалентная конфигурация.
Доказательство (от противного):
Если не существует такой конфигурации, то все конфигурации одновалентны ( есть конфигурации, которые всегда приводят к 0, есть приводящие к 1)
Возьмем начальное состояние процессов, приводящие к 0 и к 1, начнем по очереди их заменять, чтобы найти пару конфигураций разной валентности, отличающиеся начальным состоянием только одного процесса.
Тогда пусть этот процесс откажет сразу же, тогда его начальное состояние ни на что не влияет, то есть можно получить и 0 и 1 противоречие.
Лемма 2. Для бивалентной конфигурации можно всегда найти следующую за ней бивалентную.
Доказательство:
Дана конфигурация G, е - произвольное событие (процесс p, сообщение m).
С - множество конфигураций из G без e.
D - множество конфигураций, где е - это последнее событие.
Допустим в D, нет бивалентных конфигураций.
Очевидно, в ней есть и 0-валентные и 1-валентные, иначе G не бивалентна.
Рассмотрим соседние конфигурации Ci и Ci + 1, отличающиеся одним сообщением, но приводящие при получении сообщения e в Di и Di + 1 разные по валентности конфигурации.
1 случай) Если процессы коммутируют, то противоречие.
2 случай) Иначе, рассмотрим 6 положений. Просто конфигурация С, если сначала произошло событие e, если произошло сначала f, а потом e и 3 соответствующих, если процесс отказал после выполнения операции.
Тогда с одной стороны, если он умер после получения сообщения e, то остальные процессы придут к решению 0, а в случае f -  1. Но тогда, что будет, если процесс не будет просто долго принимать сообщения. Когда все процессы приняли решение, он вдруг проснулся и обработал сообщение. Противоречие.
Значит всегда есть переход в бивалентное состояние, значит можно бесконечно гонять конфигурации, но так и не решить что делать.