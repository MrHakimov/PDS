\section{Иерархия ошибок в распределенных системах. Отказ узла в асинхронной системе --- невозможность консенсуса (доказательство Фишера-Линча-Патерсона).}
 
\begin{definition} Иерархия ошибок и отказов в распределенных системах
    \begin{itemize}
        \item Отказ узла (самый простой).
        \item Отказ канала (равносильно отказу всех узлов).
        \item Ненадежная доставка (некоторые сообщения не доходят).
        \item Византийская ошибка (враги захватили узел).
    \end{itemize}
\end{definition}
 
\begin{remark}
Стоит отметить, что именно они делают программирование распределенных систем довольно 
сложным, так как являются нормой. При частичном отказе системы остальные части должны 
продолжать работать.
 
Для корректного решения частичного отказа стоит сначала определить виды систем:
\begin{itemize}
    \item Синхронные системы:
        \begin{itemize}
            \item Время передачи сообщения ограничено сверху.
            \item Можно разбить выполнение алгоритма на фазы.
        \end{itemize}
    \item Асинхронные системы:
        \begin{itemize}
            \item Время не ограничено.
            \item Время передачи конечно, если нет отказов.
        \end{itemize}
\end{itemize}
\end{remark}
 
\begin{definition} Рассмотрим свойства консенсуса в распределнной системе:
    \begin{itemize}
        \item Согласие -- все процессы должны завершиться с одним и тем же решением.
        \item Нетривиальность -- должны быть варианты исполнения, приводящие к разным решениям.
        \item Обоснованность -- решение должно быть предложением одного из процессов.
        \item Завершение -- протокол должен завершиться за конечное время.
    \end{itemize} 
\end{definition}

\begin{remark}
Достичь этих свойств без отказа легко:
    \begin{itemize}
        \item Каждый процесс шлет свое предложение вем остальным.
        \item Дожидается предложения от других процессов.
        \item Теперь из данных предложений, используя детерминированную функцию 
            (max, min, etc), выбирает решение.
    \end{itemize}
\end{remark}

\begin{remark}
    Этот алгоритм работает и в асинхронной системе.
\end{remark}

 
\begin{theorem}(FLP)
    Не существует такого детерминированного алгоритма, который при любом исполнении 
    за конечное время придет к консенсусу в асинхронной системе.
\end{theorem}
\begin{proof}
    Допустим такой алгоритм существует, тогда рассмотрим его исполнении на множестве из 0 и 1.
    Модель системы для теоремы:
    \begin{definition}
        \textit{Процесс} -- это некоторый детерминированный автомат, который может делать 3 вещи:
        \begin{itemize}
            \item Ожидать сообщения (без ограничения по времени).
            \item Отправлять сообщения.
            \item Принять решение (можно только 1 раз это сделать, но при этом 
                сообщать свое решение другим алгоритмам разрешено).
        \end{itemize}
    \end{definition}
    \begin{definition}
        \textit{Конфигурация} --- состояние всех процессов и сообщения в пути (отправленные + неполученные).
    \end{definition}
    \begin{definition}
        \textit{Шагом} в такой конфигурации называется:
        \begin{itemize}
            \item Обработка какого-то сообщения процессом.
            \item Внутреннее действие этого процесса и посылка им от нуля до
                нескольких сообщений до тех пор, пока процесс не перейдет к 
                ожиданию следующего сообщения. Это называется событием, оно
                характеризуется процессом, прочитавшем сообщение, и самим сообщением.
        \end{itemize}
    \end{definition}
    Так как все операции детерминированы, можно нарисовать полное дерево переходов.
    Начальная конфигурация содержит начальные данные для каждого из процессов.
    \begin{itemize}
        \item Может содержать сколько угодно входных данных.
        \item Начальных конфигураций много (на каждый вариант входных данных).
        \item Каждый процесс может иметь свою программу.
    \end{itemize}
    \begin{definition}
        \textit{Исполнение} -- бесконечная цепочка шагов от начального состояния, 
        так как процессы продолжают выполняться и после принятия решения.
    \end{definition}
    \begin{definition}
        \textit{Отказ} -- ситуация, когда процесс делает конечное число действий в процессе исполнения.
    \end{definition}
    \begin{definition}
        \textit{Надежная доставка} -- любое сообщение неотказавшего процесса 
        обрабатывается за конечное число шагов.
    \end{definition}
    \begin{definition}
        \textit{Согласие и решение} -- все процессы должны прийти к решению за 
        конечное число шагов (кроме возможно отказавшего).
    \end{definition}
    \begin{definition}
        \textit{Валентность}
        \begin{itemize}
            \item Конфигурация $i$-валентная, если все цепочки шагов приводят к решению $i$.
            \item Бивалентная -- если есть цепочки, приводящие и к 0, и к 1.
        \end{itemize}
    \end{definition}
    \begin{definition}
        \textit{Коммутирующие события} --- это цепочки с событиями на разных процессах, 
        которые приводят к одной и той же конфигурации, при изменении порядка их исполнения.
    \end{definition}
    \begin{lemma} 
        Существует начальная бивалентная конфигурация.
    \end{lemma}
    \begin{proof} 
        \begin{itemize}
            \item Предположим, такой конфигурации нет. Тогда все конфигурации одновалентны:
                есть конфигурации, которые всегда приводят только к 0, есть приводящие только к 1.
            \item При этом, обязательно должна быть как 0-валентная, так и 1-валентная
                конфигурации: иначе нарушается нетривиальность консенсуса.
            \item Возьмем начальные конфигурации, приводящие к 0 и к 1, начнем
                по очереди их заменять, чтобы найти пару конфигураций разной валентности,
                отличающиеся начальным состоянием только одного процесса. Так можно сделать,
                потому что любые два состояния можно соединить цепочкой, в которой каждое
                изменение применяется только к начальным данным одного процесса. Где-то
                в этой цепочки и будет смена валентности за 1 шаг.
            \item Тогда пусть этот процесс откажет сразу же, тогда его начальное состояние
                ни на что не влияет. Получается, что состояние бивалентное. Противоречие.
        \end{itemize}
    \end{proof}
    \begin{lemma}
        Для бивалентной конфигурации можно всегда найти следующую за ней бивалентную.
    \end{lemma}
    \begin{proof} 
        \enewline
        \begin{itemize}
            \item Рассмотрим конфигурацию $G$. Пусть $е$ -- произвольное событие (процесс $p$, сообщение $m$).
                Определим $C$ как множество конфигураций, достижимых из $G$ без применения
                события $e$, а $D$ -- как множество конфигураций, достижимых из $C$
                одним применением $e$: $D = e(C)$.
            \item Предположим, что в $D$ нет бивалентных конфигураций.
            \item Покажем, что в $D$ есть как 0-, так и 1-валентные конфигурации.
                \begin{itemize}
                    \item $G$ бивалентна, поэтому из нее достижима $i$-валентная
                        конфигурация $E_i$. Рассмотрим случаи:
                        \begin{itemize}
                            \item $E_i \in D$. Тогда эта конфигурация нам и подходит.
                            \item $E_i \in C$. Тогда нам подходит конфигурация $e(E_i)$.
                                (из $i$-валентной конфигурации достижимы только $i$-валентные).
                            \item $E_i$ Не лежит ни там, ни там. Значит, она достижима из
                                $G$ по какой-то цепочке, которая сначала проходит в $C$,
                                затем применяет $e$, после чего применяет еще какие-то события.
                                Возьмем $F_i$ -- конфигурацию, котороая получилась сразу
                                на выходе из $C$ после применения $e$. Она нам подойдет.
                        \end{itemize}
                \end{itemize}
            \item Зафиксируем валентность $e(G)$. Найдем какую-нибудь $D_j$ с другой
                валентностью. Тогда между ними (они упорядочены так же, как и 
                соответствующие им $C_i$) найдется пара $D_i, D_{i + 1}$, с разными
                валентностями. Ей соответсвует пара $C_i, D_{i + 1}$. Поскольку
                мы предположили, что из $G$ не достижимы бивалентные конфигурации,
                валентности $C_k$ и $D_k$ совпадают. Не умаляя общности, положим
                валентность $C_i, D_i$ равной нулю, валентность $C_{i + 1}, D_{i + 1}$
                равной единице. Так же, заменим $i$ на 0
            \item Пусть переход от $C_0$ к $C_1$ произошел при обработке сообщения $f$.
                \begin{itemize}
                    \item Если $f$ и $e$ произошли на разных процессах, то цепочки
                        \[
                            C_0 \to_f C_1 \to_e D_1,~ C_0 \to_e D_0 \to_f D_1
                        ,\]
                        очевидно, коммутируют, из чего следует бивалентность $C_0$.
                        Противоречие.
                    \item Пусть $f$ и $e$ произошли на одном процессе. Предположим,
                        что в состоянии $C_0$ этот процесс отказал, после чего система
                        пришла к консенсусу (то есть, $i$-валентной конфигурации, где
                        процессы сделали выбор) применив цепочку $\sigma$. Обозначим
                        $A = \sigma(C_0)$. Так как в состоянии $A$ уже есть консенсус,
                        $A$ одновалентно. Положим $E_0 = \sigma(D_0), E_1 = \sigma(D_1)$.
                        Рассмотрим так же альтернативные цепочки:
                        \[
                            C_0 \to_e D_0 \to_\sigma E_0,~ C_0 \to_f C_1 \to_e D_1 \to_\sigma E_1
                        .\]
                        Из того, что $A$ одновалентно, следует, что $E_0$ и $E_1$
                        одновалентны, причем имеют такую же валетность, как и $A$,
                        так как достижимы из $A$. Но $E_0 = \sigma(D_0)$ -- 0-валентная,
                        $E_1 = \sigma(D_1)$ -- 1-валентная. Противоречие.
                \end{itemize}
        \end{itemize}
    \end{proof}
    Значит всегда есть переход в бивалентное состояние, то есть существует бесконечное исполнение,
    посещяющее только бивалентные конфигурации, то есть не приводящая к консенсусу.
\end{proof}

