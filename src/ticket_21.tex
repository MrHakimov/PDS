\section{Иерархия ошибок в распределенных системах. Отказ узла в асинхронной системе --- невозможность консенсуса (доказательство Фишера-Линча-Патерсона).}
 
\begin{definition} Иерархия ошибок и отказов в распределенных системах
    \begin{itemize}
        \item 1) отказ узла (самый простой)
        \item 2) отказ канала (равносильно отказу всех узлов)
        \item 3) ненадежная доставка (некоторые сообщения недоходят)
        \item 4) Византийская ошибка (враги захватили узел и пытаются тебя поиметь)
    \end{itemize}
\end{definition}
 
\begin{remark}
Стоит отметить, что именно они делают программирование распределенных систем довольно сложным, так как являются нормой. При частичном отказе системы остальные части должны продолжать работать.
 
Для корректного решения частичного отказа стоит сначала определить виды систем
\begin{itemize}
    \item 1) Синхронные системы 
    \item 1.1) время передачи сообщения ограничено сверху
    \item 1.2) можно разбить выполнение алгоритма на фазы
    \item 2) Асинхронные системы
    \item 2.1) время не ограничено 
    \item 2.2) время передачи конечно, если нет отказов
\end{itemize}
\end{remark}
 
\begin{definition} Рассмотрим свойства консенсуса в распределнной системе:
    \begin{itemize}
        \item 1) Согласие --- Все процессы должны завершиться с одним и тем же решением.
        \item 2) Нетривиальность --- Должны быть варианты исполнения, приводящие к разным решениям.
        \item 3) Обоснованность --- Решение должно быть предложением одного из процессов.
        \item 4) Завершение --- Протокол должен завершиться за конечное время.
    \end{itemize} 
\end{definition}
 
\begin{remark}
Достичь этих свойств без отказа легко:
    \begin{itemize}
        \item 1) Каждый процесс шлет свое предложение вем остальных.
        \item 2) Дожидается предложение от других процессов.
        \item 3) Теперь из данных предложений, используя детерминированную функцию (max, min, etc), выбирает решение.
    \end{itemize}
\end{remark}
 
Этот алгоритм работает и в асинхронной системе.
 
\begin{theorem}
    \textit{КЛЮЧЕВАЯ ТЕОРЕМА КУРСА (Фишера-Линча-Патерсона)}
 
    Не существует такого детерминированного алгоритма, который при любом исполнении за конечное время придет к консенсусу в асинхронной системе.
\end{theorem}
\begin{proof} (от противного)
    \newline
    Допустим такой алгоритм существует, тогда рассмотрим его исполнении на множестве из 0 и 1.
    \newline
    \newline
    Модель системы для теоремы:
    \begin{definition}
        \textit{Процесс} --- это некоторый детерминированный автомат, который может делать 3 функции:
        \begin{itemize}
        \item 1) Указать ожидать получения сообщения (нет возможности указать время ожидания)
        \item 2) Отправить сообщение
        \item 3) Принять решение (можно только 1 раз это сделать, но при этом сообщать свое решение другим алгоритмам разрешено)
    \end{itemize}
    \end{definition}
    \begin{definition}
        \textit{Конфигурация} --- состояние всех процессов + сообщения в пути (отправленные + неполученные)
    \end{definition}
    \begin{definition}
        Шагом в такой конфигурации называется 
        \begin{itemize}
            \item 1) обработка какого-то сообщения процессом
            \item 2) внутреннее действие этого процесса и посылка им от нуля до нескольких сообщений до тех пор, пока процесс не перейдет к ожиданию следующего сообщения.
        \end{itemize}
    \end{definition}
    Так как все операции детерминированы, можно нарисовать полное дерево переходов.
    \newline
    Начальная конфигурация содержит начальные данные для каждого из процессов.
    \begin{itemize}
        \item 1) может содержать сколько угодно входных данных
        \item 2) начальных конфигураций много (на каждый вариант входных данных)
        \item 3) Каждый процесс может иметь свою программу
    \end{itemize}
    \begin{definition}
        \textit{Исполнение} --- бесконечная цепочка шагов от начального состояния, так как процессы продолжают выполняться и после принятия решения.
    \end{definition}
    \begin{definition}
        \textit{Отказ} --- процесс, который делает конечное число шагов в процессе исполнения.
    \end{definition}
    \begin{definition}
        \textit{Надежная доставка} --- любое сообщение неотказавшего процесса обрабатывается за конечное число шагов.
    \end{definition}
    \begin{definition}
        \textit{Согласие и решение} --- все процессы должны прийти к решению за конечное число шагов (кроме возможно отказавшего)
    \end{definition}
    \begin{definition}
        \textit{Валентность}
        \begin{itemize}
            \item Конфигурация i-валентная, если все цепочки шагов приводят к решению i
            \item Бивалентная --- если есть цепочки, приводящие к 0, и цепочки, приводящие к 1.
        \end{itemize}
    \end{definition}
    \begin{definition}
        \textit{Коммутирующие события} --- это цепочки с событиями на разных процессах, которые приводят к одной и той же конфигурации, при изменении порядка их исполнения.
    \end{definition}
    \begin{lemma} Существует начальная бивалентная конфигурация.
    \end{lemma}
    \begin{proof} (от противного)
        \begin{itemize}
            \item Если не существует такой конфигурации, то все конфигурации одновалентны ( есть конфигурации, которые всегда приводят к 0, есть приводящие к 1)
            \item Возьмем начальное состояние процессов, приводящие к 0 и к 1, начнем по очереди их заменять, чтобы найти пару конфигураций разной валентности, отличающиеся начальным состоянием только одного процесса.
            \item Тогда пусть этот процесс откажет сразу же, тогда его начальное состояние ни на что не влияет, то есть можно получить и 0 и 1 противоречие.
        \end{itemize}
    \end{proof}
    \begin{lemma}
    Для бивалентной конфигурации можно всегда найти следующую за ней бивалентную.
    \end{lemma}
    \begin{proof} (рассмотрим что у нас есть)
        \begin{itemize}
            \item Дана конфигурация G, е --- произвольное событие (процесс p, сообщение m). С --- множество конфигураций из G без e. D --- множество конфигураций, где е --- это последнее событие.
            \item Допустим в D, нет бивалентных конфигураций.
            \item Очевидно, в ней есть и 0-валентные и 1-валентные, иначе G не бивалентна.
            \item Рассмотрим соседние конфигурации Ci и Ci + 1, отличающиеся одним сообщением, но приводящие при получении сообщения e в Di и Di + 1 разные по валентности конфигурации.
            \item 1 случай) Если процессы коммутируют, то противоречие.
            \item 2 случай) Иначе, рассмотрим 6 положений. Просто конфигурация С, если сначала произошло событие e, если произошло сначала f, а потом e и 3 соответствующих, если процесс отказал после выполнения операции.
            \item Тогда с одной стороны, если он умер после получения сообщения e, то остальные процессы придут к решению 0, а в случае f -  1. Но тогда, что будет, если процесс не будет просто долго принимать сообщения. Когда все процессы приняли решение, он вдруг проснулся и обработал сообщение. Противоречие.
        \end{itemize}
    \end{proof}
    Значит всегда есть переход в бивалентное состояние, значит можно бесконечно гонять конфигурации, но так и не решить что делать.
\end{proof}