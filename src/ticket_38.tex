\section{Leader/Follower репликация. Failover (для синхронного и асинхронного случаев), масштабирование репликации, снимки данных.}

\textit{Определения см. в предыдущем билете.}

\begin{definition}
    \textit{Failover} --- процесс замены упавшего лидера на новый.
\end{definition}

\begin{algorithm}(Замена лидера, синхронная репликация)
    \begin{itemize}
        \item Можем заменить лидера на любую реплику, так как каждая реплика содержит актуальные данные.
        \item В системе ни в какой момент времени не должно быть двух лидеров.
        \item Поэтому сначала нужно выключить старого лидера (например, изолировать на уровне сети).
        \item Только после отключения старого лидера, включаем новый.

        \item \textbf{Незавершенная операция}:
        \begin{itemize}
            \item Если лидер успел отреплицировать последнюю операцию хотя бы на один узел, то какой-то клиент мог бы успеть прочитать результат выполнения операции с этого узла. Такой узел станет новым лидером и отреплицирует операцию на остальные узлы.
            \item Если лидер не успел отреплицировать последнюю операцию ни на один узел, то ни один клиент не мог успеть прочитать результат выполнения операции. Также клиент, который послал запрос на применение операции, не успел получить подтверждение о завершении операции. Таким образом, эту операцию можно просто забыть.
        \end{itemize}

    \end{itemize}

\end{algorithm}

\begin{algorithm}(Замена лидера, асинхронная репликация)
    \begin{itemize}
        \item Невозможно произвести замену без потерь, так как потенциально на каждой реплике нет какого-то суффикса журнала.
        \item Можно ждать восстановления лидера (и не обслуживать запросы на запись) или произвести замену с минимальной потерей данных.
        \item Выбираем реплику с самым длинным журналом и делаем её новым лидером. Так мы потеряем меньше всего данных.
        \item В системе всё ещё не может быть одновременно двух лидеров, поэтому сначала выключаем старый, а затем назначаем нового.
        \item Нарушена \textit{Durability}: лидер сказал клиенту, что его транзакция завершилась успешно, но данные его транзакции были потеряны.
        \item Когда прежний лидер восстановится, произойдет объединение логов для обеспечения \textit{Eventual consistency}.
    \end{itemize}

\end{algorithm}

\begin{algorithm}(Объединение логов)
    \begin{itemize}
        \item После восстановления старого лидера в его журнале есть суффикс, которого нет у нового лидера.
        \item У нового лидера также есть суффикс, которого нет у старого.

        \item \textbf{Решение конфликтов}

        Часть суффикса старого лога может быть без проблем применена на новом лидере. Но некоторые записи будут конфликтовать с суффиксом нового лога. Возможные решения:
        \begin{itemize}
            \item Забыть конфликтующую запись из старого лога.
            \item Использовать \textit{CRDT}. Но записи из суффикса лога нового лидера иногда не имеют смысла без записей из суффикса старого лидера, поэтому такие системы сложно проектировать.
        \end{itemize}

    \end{itemize}

\end{algorithm}

\begin{remark}
    Чем больше реплик, тем больше времени надо потратить лидеру, чтобы переслать на каждую весь журнал. Это ограничивает масштабируемость.
\end{remark}

Способы решения проблемы масштабируемости репликации:
\begin{itemize}
    \item \textit{Каскады репликации}.
    \begin{itemize}
        \item Реплики составляют древовидную структуру, каждая реплика имеет свой уровень.
        \item Реплика, получив изменение, пересылает его репликам на следующем уровне.
        \item Таким образом, лидер тратит относительно немного времени на рассылку изменения репликам.
    \end{itemize}

    \item \textit{Gossip}.
    \begin{itemize}
        \item Лидер пересылает журнал подмножеству реплик.
        \item Дальше реплики сами рассылают друг другу недостающие фрагменты.
        \item На каждой реплике применяем только записи из последовательного префикса, до первой ``дырки``.
    \end{itemize}
\end{itemize}

\begin{example}(Асинхронная репликация на практике)
    \begin{itemize}
        \item Снимки данных
        \begin{itemize}
            \item Подключаем к лидеру новую реплику в асинхронном режиме.
            \item Передаём на новую реплику префикс лога.
            \item Как только получили необходимые данные, отключаем реплику.
            \item Таким образом, получили снимок данных, содержащий префикс всех операций.
        \end{itemize}

        \item Применение снимков для инициализации новых реплик.
        \begin{itemize}
            \item При подключении новой реплики не хотим передавать на неё весь журнал, с первой операции.
            \item Инициализируем новую реплику снимком данных, отражающим операции $[1-N]$.
            \item Начнём передавать на неё журнал с $N+1$-ой записи.
        \end{itemize}

        \item Разные реплики могут работать в разных режимах. Например, некоторые реплики можно сделать синхронными, а некоторые асинхронными.
        \item Имеем хотя бы одну синхронную реплику на случай падения лидера.

    \end{itemize}

\end{example}
