\section{Шардирование. Общий принцип. Статическое отображение,
остаток от деления, расширяемое побитовое хеширование, битовый бор,
постоянное число секций.}

\begin{definition}
    \textit{Шардирование}.
    \begin{itemize}
        \item Узлы распределенной системы хранят непересекающиеся
            подмножества данных.
        \item Пока что, система не поддерживает запросы, относящиеся к данным,
            расположенным сразу на нескольких серверах.
        \item Рассматриваем простейшие запросы по ключу (\texttt{get}, \texttt{set},
            \texttt{cas}).
        \item Клиенты должны знать, как понять, на каком сервере хранится ключ.
            Хранить это отображение в явном виде не получится, так как его придется
            хранить на отдельном сервере.
    \end{itemize}
\end{definition}

\begin{algorithm}(Шардирование статическим отображением)

    Зафиксируем множество узлов, построим отображение ключей на эти узлы.
    Это отображение меняться не будет, поэтому пусть каждый процесс знает его.
    \textit{Плюсы}:
    \begin{itemize}
        \item Легко реализовать.
    \end{itemize}
    \textit{Минусы}:
    \begin{itemize}
        \item Неравномерное распределение ключей.
        \item Фиксированное множество узлов.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Наивный подход)

    Построим такое отображение ключей в номера узлов:
    \[
        \texttt{nodeid} \leftarrow \texttt{hash}(k) \mod N
    ,\]
    где $N$ -- число узлов.
    \textit{Плюсы}:
    \begin{itemize}
        \item Переменное число узлов.
        \item Простота реализации.
    \end{itemize}
    \textit{Минусы}:
    \begin{itemize}
        \item $\Theta(N)$ перемещений данных при добавлении или удалении узла.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Расширяемое побитовое хеширование)

    Пусть число серверов всегда равно $2^m$ (m меняется). Тогда
    сделаем отображение, в котором номером сервера для конкретного ключа
    будет число, полученное из первых $m$ бит его хеша. При добавлении узла,
    докупается столько же узлов, сколько было. При этом каждый сервер отдаст
    примерно половину своих данных новому серверу.
\end{algorithm}

\begin{algorithm}(Битовый бор)

    Отображение будет построено на боре, алфавит которого состоит из нуля и
    единицы. Листья бора соответствуют узлам, на которых хранятся ключи с
    префиксом хеша, равным строке от корня бора до листа.
    \begin{itemize}
        \item При добавлении узла, расщепляем переполненный лист на два,
            передавая на новый узел половину данных.
        \item При удалении узла:
            \begin{itemize}
                \item Если брат -- тоже лист, просто передаем свои ключи ему.
                \item Если брат -- не лист, то заменяем все поддерево родителя
                    одним листом.
            \end{itemize}
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Постоянное число секций)

    \begin{itemize}
        \item Заводим $S$ секции, не меняем их число.
        \item Выбираем способ отображения влюча в номер секции.
        \item Храним на главном сервере информацию о том, где какая секция лежит.
        \item При добавлении или удалении узла перемещаем данные секциями.
    \end{itemize}
\end{algorithm}

\begin{remark}(О секциях)
    \enewline
    \begin{itemize}
        \item Секций должно быть не очень много, чтобы информацию от отображении
            секций на сервера можно было бы поместить на один сервер. При этом
            их должно быть на несколько порядков больше числа серверов,
            чтобы в дальнейшем можно было маштабироваться горизонтально.
        \item Можно делать балансировку нагрузки, определяя загруженные сервера,
            горячие данные и т.п. Для этого тоже полезно, чтобы секций было много.
    \end{itemize}
\end{remark}
