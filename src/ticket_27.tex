\section{Paxos. Алгоритм, его свойства.}

\begin{algorithm}(Paxos [Лампорт, 1989])

    \begin{itemize}
        \item Это -- первый практически применимый алгоритм асинхронного
            консенсуса.
        \item Каждый процесс выбирает значение из множества предложенных.
        \item Алгоритм гарантирует согласие при любых отказах и при произвольных
            задержках сообщений.
        \item По теореме FLP, алгоритм не может гарантировать завершения за
            конечное время. Но в случаях, когда ошибки случаются нечасто,
            консенсус достигается за конечное число шагов.
    \end{itemize}
    В системе будет три вида процессов.
    \begin{itemize}
        \item Решаем задачу однократного консенсуса.
        \item Есть множество предлагающих процессов (proposers). Например, они
            пытаются выполнить какую-то операцию RSM, и предлагают
            свою в качестве следующей.
        \item Принимающих решение процессов (acceptors) в системе будет несколько. Если
            сделать один принимающий процесс, то система будет слишком
            уязвимой к отказам.
        \item Есть также множество узнающих процессов (learners), которые могут
            совсем не совпадать ни с предлагающими, ни с принимающими решение.
    \end{itemize}
    Будем строить алгоритм на основе кворума.
    \begin{itemize}
        \item Кворум и множество предлагающих процессов заранее зафиксированы.
        \item Можно использовать любой кворум.
        \item Кворумы используются потому, что в такой схеме отказ какого-либо
            процесса не остановит работу.
        \item Предполагается, что отказы временные.
    \end{itemize}
    Среди множества принимающих процессов будет лидер. Предлагающие процессы
    должны знать (заранее фиксированное) множество принимающих процессов
    и кто из них лидер (лидер будет меняться).
    \begin{itemize}
        \item Выбор лидера -- тоже задача консенсуса. Поэтому выбирать его
            будем за конечное время без гарантии того, что лидер получится один.
        \item Алгоритм все равно будет гарантировать согласие. Но гарантии завершения
            не будет до тех пор, пока лидеров несколько.
    \end{itemize}
    Основа алгоритма.
    \begin{itemize}
        \item Для прихода к консенсусу алгоритм делает один или несколько
            ранудов голосования.
        \item Раунд голосования инициируется лидером. Все предложения высылаются
            ему, он же их ставит на голосование.
        \item Раундов может быть несколько только если лидер не один.
        \item Несколько голосований может происходить одновременно. Вся структура
            алгоритма построена так, чтобы согласие все равно было обеспечено.
        \item Каждое голосование имеет свой уникльный номер. При отсутствии прогресса,
            лидер может пересоздать голосование с новым номером.
    \end{itemize}
    1-я фаза голосования.
    \begin{itemize}
        \item[1a] Подготовка. Лидер инициирует голосование и рассылает кворуму
            принимающих сообщение $(1a, k)$. $k$ -- номер голосования.
        \item[1b] Обещание. Получив сообщение $(1a, k)$, принимающий обещает
            не принимать предложения с меньшим номером. Далее он отвечает
            \begin{itemize}
                \item $(1b, k, ack, k', v')$, где $(k', v')$ -- информация
                    о принятом предложнии с максимальным номером $k' < k$,
                    или $k' = 0$, если ничего еще не было принято.
                \item $(1b, k'', nack)$, если уже было дано другое обещание с
                    $k'' > k$. Лидер ответит $(1a, k'')$.
            \end{itemize}
    \end{itemize}
    2-я фаза голосования.
    \begin{itemize}
        \item[2a] Запрос. Лидер, получив обещания $(ab, k, ack, k', v')$ от
            кворума принимающих, предлагает значение.
            \begin{itemize}
                \item Берет значение $v'$ для наибольшего $k'$, полученного
                    от принимающих, или предлагает свое значение, если
                    все $k' = 0$.
                \item Посылает $(2a, k, v)$ кворуму принимающих.
                \item На второй фазе можно использовать другой кворум.
            \end{itemize}
        \item[2b] Подтверждение. Если принимающий получает запрос $(2a, k, v)$,
            и он не давал обещания для $k' > k$, то он принимает предложение $(k, v)$
            и посылает сообщение $(2b, k, v)$ всем узнающим.
        \item[2c] Узнающий, получив сообщение $(2b, k, v)$ от кворума принимающих,
            узнает о том, что принято значение $v$.
    \end{itemize}
\end{algorithm}

\begin{theorem}(Корректность Paxos)

    Если есть два принятых предложения $(k, v)$, $(k', v')$, то $v = v'$.
\end{theorem}
\begin{proof}
    Предположим противное, и $v \neq v'$. Без потери общности, будем считать, что
    $k < k'$ и $k'$ такой наименьший.
    \begin{itemize}
        \item Внутри одного голосования не может быть принято два разных значения,
            потому что лидер этого голосования выставил ровно одно значение.
        \item Несогласованность может быть вызвана только разными голосованиями
            (с разными лидерами).
        \item Предположим, что есть два параллельно идущих голосования. Поскольку
            мы используем кворум, есть хотя бы один принимающий, который
            знает про оба голосования. Именно этот принимающий и не даст
            принять разные значения.
    \end{itemize}
\end{proof}
