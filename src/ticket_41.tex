\section{Слабые модели консистентности. Мотивация, чтение согласованного префикса.}

\textit{Первую часть вопроса см. в билете 39.}

\begin{example}(Чтение согласованного префикса)

Если в системе есть шардирование, то мы хотим запретить ситуацию, когда клиент читает измененные данные, а вот данные, от которых они зависят, будут прочитаны не измененными. Например, клиент видит зависимую сущность, но не видит сущность, от которой она зависит. При отсутствии шардирования получаем гарантию автоматически. Есть несколько подходов к реализации такой слабой модели консистентности:

\begin{itemize}
    \item \textit{Настройка схемы шардирования:}
    \begin{itemize}
        \item Если сущность Y может зависеть от сущности X --- будем хранить их в одной секции.
        \item Например, можно хранить все сообщения из одного чата в одной и той же секции (секционирование по hash(chat\_id)).
        \item Но сделать так можно не всегда.
    \end{itemize}

    \item \textit{Cпецифичные для приложения методы}
    \begin{itemize}
        \item Например, просто не будем отображать комментарий, если не можем отобразить исходное сообщение.
        \item Такое могло произойти, если сообщение еще не успело отреплицироваться на реплику, с которой читаем.
        \item Как только исходное сообщение будет получено, отобразим и само сообщение, и комментраии.
    \end{itemize}

    \item \textit{Версионирование записей}

\end{itemize}

\end{example}

\begin{algorithm}(Версионирование записей)
    \begin{itemize}
        \item Каждая запись в логе хранит $N$ чисел.
        \item Одно число --- порядковый номер записи в логе текущего шарда.
        \item Остальные --- порядковые номера записей в логах других шардов, от которых зависит наша запись.
        \item Хотим читать с остальных шардов только те записи, которые были не раньше записи, от которой мы зависим.
    \end{itemize}

    Возможная реализация алгоритма:
    \begin{lstlisting}
        versions[1..N] <- null
        while True:
            for i <- 1..N if versions[i] == null:
                versions[i] = fetchShard(i)
            invalidations = False
            for i <- 1..N, j <- 1..N, if i /= j and
                versions[i] /= null and versions[j] /= null:

                if versions[i].dependencies[j] > versions[j].v:
                    invalidations = True
                    versions[j] = null
            if not validations:
                return versions
    \end{lstlisting}

    Проблемы такого подхода:
    \begin{itemize}
        \item Записи могут бесконечно друг друга патыться провалидировать, поэтому завершаемость алгоритма не гарантируется.
        \item Одна из более поздних записей может соответствовать удалению сущности, от которой мы зависим. Решения:
        \begin{itemize}
            \item Можно никогда не удалять данные, только помечать как удалённые.
            \item Можно использовать персистентные структуры данных и запрашивать нужную версию.
        \end{itemize}
    \end{itemize}
\end{algorithm}
