\section{Распределённое объединение. Использование границ и слияние
  отсортированных последовательностей.}

Для сортировки методом слияния достаточно реализовать процедуру слияния ---
объединения отсортированных последовательностей.

\begin{algorithm}(Распределенное объединение)
  \begin{itemize}
    \item На каждом из $R$ узлов лежит по одному файлу, каждый из которых
      содержит данные, отсортированные по ключу. Задача заключается в их
      слиянии.
    \item Узел, производящий слияние, делает это по стандартному алгоритму с
      использованием кучи.
    \item Так как результат может заполнить всю память на объединяющем узле,
      при переполнении задача продолжается на другом узле.
    \item Узлы, хранящие сливаемые последовательности, должны уметь отдавать
      очередной элемент по запросу, а также создавать контрольные точки и
      откатываться к ним. Это требуется для корректного возобновления слияния
      после падения узла слияния. Контрольные точки должны создаваться при
      переполнении очередного узла слияния.
  \end{itemize}
\end{algorithm}

\textbf{Оптимизация: блочное чтение.}
\begin{itemize}
  \item Чтение по одному ключу с узлов неэффективно из-за накладных расходов на
    передачу данных по сети.
  \item Узел, производящий слияние, может получать блок ключей и кешировать его.
    Если блок от какого-либо узла исчерпывается, запрашивается новый, а также
    создается новая контрольная точка.
\end{itemize}

\lstset{
    language=Python,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\begin{algorithm}(Распределенная сортировка)
  \newline
  Рассмотрим другой подход к распределенной сортировке: распределим ключи
  равномерно по нескольким узлам так, чтобы на каждом лежали только те, которые
  попадают в некоторый интервал. Затем будет достаточно отсортировать ключи на
  каждом узле локально и выдать в порядке интервалов.
  \newline
  \newline
  Пусть $m$ --- общее число ключей, $n$ --- число узлов, на которых будет
  производиться локальная сортировка. Найдем такие границы интервалов:
  $$a_1 < a_2 < \ldots < a_{n - 1}$$
  Что распределение ключей по этим границам:
  $$r(x) =
    \begin{cases}
      1, & x < a_1 \\
      2, & a_1 \leq x < a_2 \\
      \ldots \\
      n, & x \geq a_{n - 1}
    \end{cases}$$
  Будет равномерным:
  $$P(r(x) = 1) \approx P(r(x) = 2) \approx \ldots \approx P(r(x) = n)$$
  Для этого узнаем распределение ключей, взяв выборку из $k$ ключей:
  \begin{lstlisting}
fun mapper(doc: [Key]) -> [(String, Key)]:
    for key in doc:
        if random.uniform(0, 1) < k / m:
            yield "sample", key
  \end{lstlisting}
\end{algorithm}
