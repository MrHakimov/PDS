\section{Шардирование. Общий принцип, хеширование рандеву, консистентное 
хеширование, Multi-Probe Consistent Hashing.}

\textit{Первую часть вопроса см. в предыдущем билете.}

\begin{algorithm}(Rendezvouz hashing)
    
    Зафиксируем число $K$. На основе ``хорошей'' хеш-функции построим
    следующее отображение:
    \[
        \texttt{node\_id} \leftarrow \argmax_{i = 0}^{K - 1}(h(key~\mid~i))
    .\]
    \begin{itemize}
        \item При добавлении узла каждый узел перемещает только те ключи,
            которые должны перейти на новый узел:
            \[
                h(key~\mid~\texttt{new\_node\_id}) > h(key~\mid~\texttt{cur\_node\_id})
            .\]
        \item При удалении узла перемещаются только ключи с этого узла.
        \item Поиск узла по ключу осуществляется за $\cO(K)$.
    \end{itemize}
\end{algorithm} 

\begin{algorithm}(Consistent Hashing)
    
    Рассмотрим возможные значения хеш-функции как точки кольца. Разместим на этом
    кольце все сервера. Ключ будет лежать на том сервере, который находится ближе всего
    по часовой стрелке. 
    \begin{itemize}
        \item При добавлении узла, ключи перемещаются только на новый узел.
        \item При удалении узла, ключи перемещаются только с него.
    \end{itemize}
\end{algorithm}

\begin{remark}(Детали реализации Consistent Hashing)
    \enewline
    \begin{itemize}
        \item Список узлов можно хранить в дереве поиска или в отсортированном массиве.
        \item Перемещаются только непрерывные отрезки ключей (по хешам). На каждом
            узле можно хранить отображение из хешей в списки ключей.
    \end{itemize}
\end{remark}

\begin{remark}(О Consistent Hashing)
    \enewline
    \begin{itemize}
        \item Возможно неравномерное распределение ключей, из-за случайного выбора
            точек для узлов.
        \item При удалении узла все его ключи перемещаются на единственный узел.
    \end{itemize}
\end{remark}

\begin{algorithm}(Consistent Hashing: vnodes)
    
    Пусть каждому физическому узлу соответствует несколько виртуальных:
    \[
        h(\texttt{node} ~\mid~ 0),~ h(\texttt{node} ~\mid~ 1),~ \ldots
    .\]
    Чем больше виртуальных копий, тем равномернее распределение ключей по узлам
    и больше нагрузки на память и время.
\end{algorithm}

\begin{algorithm}(Multi-Probe Consistent Hashing)
    
    Пусть каждому узлу соответствует только одна точка на круге. Теперь будем
    много раз проецировать ключ на круг, аналогично тому, как мы делали в vnodes.
    Берем ближайшую точку, соответствующую узлу. Тратится меньше памяти, но больше
    времени. (Слабый проигрыш по времени, но сильный выигрыш по памяти).
\end{algorithm}

