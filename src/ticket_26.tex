\section{Недетерминированные алгоритмы консенсуса. Алгоритм Бен-Ора.}

\begin{remark}
    Невозможность построения алгоритма консенсуса при наличии ошибок доказывается
    только в случае выполнения следующих свойств:
    \begin{itemize}
        \item Система асинхронная.
        \item Алгоритм детерминированный.
    \end{itemize}
    Избавимся от второго требования.
\end{remark}

\begin{remark}
    К недетерминированным алгоритмам консенсуса предъявим требования:
    \begin{itemize}
        \item Консенсус достигается с вероятностью 1.
        \item Порядок исполнения операций выбирает ``противник''.
    \end{itemize}
\end{remark}

\begin{algorithm}(Бен-Ор)
    
    Пусть в системе $N$ процессов, отказать могут только $f$.
    \begin{itemize}
        \item Будет множество раундов. Каждый раунд состоит из двух фаз.
        \item На каждой фазе процесс будет слать $N$ сообщений и ждать
            $N - f$ ответов.
        \item В первой фазе процесс рассылает свое предпочтение:
            $(1, k, p)$. Здесь $k$ -- номер раунда, единица означает
            первую фазу, $p$ -- препочтение.
            \begin{itemize}
                \item Процесс считает голоса, пришедшие от других процессов.
                    Если какое-то значение набрало больше $N/2$ голосов,
                    то оно \textit{ратифицирует}.
                \item Во второй фазе процесс шлет сообщения $(2, k, v)$ --
                    где $v$ -- ратифицированное значение или $?$, если
                    его нет.
                \item После того, как процесс ратифицировал или получил
                    ратификацию во второй фазе, он меняет свое предпочтение на $v$.
                \item Получив больше $f$ ратификаций процесс принимает решение $v$,
                    продолжая при этом исполняться.
                \item Не получив ратификации, процесс меняет свое предпочтение
                    на случайное.
            \end{itemize}
    \end{itemize}
\end{algorithm}

\begin{lemma}
    В одном раунде процессы не могут ратифицировать разные значения.
\end{lemma}

\begin{lemma}
    Если процесс принял решение $v$, то в следующем раунде все процессы
    начнут с предпочтением $v$.
\end{lemma}
\begin{proof}
    \enewline
    \begin{itemize}
        \item Чтобы принять решение, процесс получил минимум $f + 1$
            сообщений вида $(2, k, v)$. Подобных сообщений с другим
            $v$ быть не могло по предыдущей лемме.
        \item Чтобы начать раунд с другим предпочтением процесс должен был
            получить $N - f$ сообщений вида $(2, k, ?)$.
        \item Эти сообщения, очевидно, посланы разными узлами. Но тогда
            \[
                (N - f) + (f + 1) = N + 1 > f
            .\]
            Противоречие.
    \end{itemize}
\end{proof}

\begin{remark}(Об алгоритме Бен-Ора)
    \enewline
    \begin{itemize}
        \item Чтобы алгоритм все-таки заканчивался, нужно рассылать еще третий
            тип сообщения ``решение''. Для корректности это не обязательно:
            за конечное число шагов все равно все примут решение.
        \item Система асинхронная, то есть сообщения не обязаны приходить
            раунд за раундом. Но поскольку мы ждем $N - f$ сообщений в каждой
            фазе, алгоритм получается ``почти асинхронный''.
        \item Даже если сильный противник знает все о состоянии системы,
            вероятность завершения алгоритма за конечное число шагов
            равна единице.
        \item Время работы алгоритма объясняется примерно так: на каждом
            раунде все процессы начнут с одинаковым предпочтением
            с вероятностью, не меньшей $2^{-N}$.
    \end{itemize}
\end{remark}

