\section{Leader/Follower репликация. Общий принцип, реализация, синхронная и асинхронная репликация.}

\begin{definition}
    \textit{Leader/Follower} репликация. На каждом узле хранятся одни и те же данные.

    \begin{itemize}
        \item Один узел является лидером, принимает запросы на чтение и запись.
        \item Остальные узлы являются репликами, принимают запросы только на чтение.
    \end{itemize}

    \textit{Преимущества}:
    \begin{itemize}
        \item Можно читать из любой копии $\Rightarrow$ увеличиваем пропускную способность на чтение (но не на запись).
        \item Можно читать из ближайшей копии $\Rightarrow$ уменьшаем задержку чтения (но не записи).
        \item Храним данные в нескольких копиях $\Rightarrow$ увеличиваем надежность, так как если одна реплика недоступна, можем читать данные из любой другой.
    \end{itemize}

\end{definition}

\begin{remark}
    Так как лидер жестко выбран заранее, нет необходимости постоянно приходить к консенсусу по поводу его выбора.
\end{remark}

\begin{definition}
    \textit{CDN (Content Delivery Network)} --- системы, основанные на Leader/Follower репликации. Используются в случаях, когда нужно часто читать данные, при этом запись происходит редко.
\end{definition}

\begin{algorithm}(Реализация Leader/Follower)
    Клиент посылает запрос на изменение. Лидер должен разослать эти измения репликам. Существует несколько вариантов репликации:
    \begin{itemize}
        \item \textbf{Репликация на уровне команд}.

        Лидер в текстовом виде рассылает исполненные команды.

        \textit{Преимущества:}
        \begin{itemize}
            \item Пересылаем небольшой объем данных, так как сколько бы данных не затрагивала команда, мы пересылаем только ее текстовый вид.
        \end{itemize}

        \textit{Проблемы:}
        \begin{itemize}
            \item Недетерминированные команды (рандом, текущее время). Решение: можно пересылать не функцию, а результат ее выполнения.
            \item Не гарантируется одинаковый порядок исполнения команд. Решение: использование журналов.
        \end{itemize}
        \item \textbf{Репликация на уровне журналов}.

        Каждая реплика ведет журнал изменений. Лидер рассылает записи из журнала. Запись в жернале имеет вид $(O, F, X, Y)$ --- объект, поле, старое и новове значения.

        \textit{Преимущества:}
        \begin{itemize}
            \item Определенный порядок.
            \item Полный детерминизм.
            \item Не пересылаем записи откаченных транзакций.
            \item Записи из журналов имеют более простой формат, а значит, применять их проще, чем команды.
        \end{itemize}

        \textit{Недостатки:}
        \begin{itemize}
            \item Большой объем пересылаемых данных. Но в реальной жизни преимущества перевешивают этот недостаток.
        \end{itemize}

    \end{itemize}

\end{algorithm}

\begin{definition}
    \textit{Синхронная репликация:}
    \begin{itemize}
        \item Лидер применяет операцию локально и затем рассылает ее на все реплики.
        \item Реплики применяют операцию локально и отвечают лидеру.
        \item Лидер дожидается подтверждения от всех реплик, что они применили операцию.
        \item После этого лидер подтверждает применение операции у себя и сообщает клиенту о завершении операции.

        \item \textbf{Актуальность данных}
        \begin{itemize}
            \item Если лидер сообщил клиенту о завершении операции, то эта операция применена на всех репликах.
            \item Таким образом, каждая реплика содержит актуальные данные, и ее состояние совпадает с состоянием лидера.
            \item Чтение из любой реплики даст один и тот же результат.
            \item Консистентность $\Rightarrow$ жертвуем доступностью.
        \end{itemize}

        \item \textbf{Недоступные узлы}
        \begin{itemize}
            \item При недоступности любого узла система не может обрабатывать запросы на запись.
            \item Но при этом может обрабатывать запросы на чтение и получать актуальные данные на любом доступном узле.
        \end{itemize}

    \end{itemize}
\end{definition}

\newpage

\begin{definition}
    \textit{Асинхронная репликация:}
    \begin{itemize}
        \item Лидер применяет операцию локально и сразу сообщает клиенту о завершении операции.
        \item После этого лидер рассылает операцию репликам.
        \item Не ждем пока реплики получат изменения и подтвердят их.
        \item Можно пересылать не каждый запрос, а группировать их.

        \item \textbf{Недоступные узлы}
        \begin{itemize}
            \item Если недоступна реплика, то система всё равно может обрабатывать любые запросы.
            \item Если лидер упал, мы не можем произвести замену без потерь, так как потенциально на каждой реплике нет какого-то суффикса журнала.
            \item Можем ждать, пока лидер поднимется. До этого момента система не сможет обслуживать запросы на запись.
            \item А можем произвести замену с минимальной потерей данных.
        \end{itemize}
    \end{itemize}
\end{definition}
