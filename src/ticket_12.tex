\section{Глобальные свойства. Стабильные и нестабильные предикаты.
Слабый конъюнктивный предикат. Централизованный алгоритм.}

\begin{definition}
    \textit{Глобальным предикатом} называется предикат, определенный
    над состоянием системы в целом. Под состоянием системы подразумевается
    согласованный срез.
\end{definition}

\begin{definition}
    Предикат $P(G)$ называется стабильным, если для любых согласованных
    срезов $G, H$ выполняется:
    \[
        G \subset H \wedge P(G) \Lra P(H)
    .\]
\end{definition}

\begin{algorithm}(Простой алгоритм для стабильных предикатов)

    Строим согласованный срез при помощи алгоритма Чанди-Лампорта,
    проверяем на нём выполненность предиката. Если он верен, то будет
    верен и в дальнейшем.
\end{algorithm}

\begin{definition}
    \textit{Локальным} называется предикат, зависящий от состояния
    только одного процесса.
\end{definition}

\begin{remark}
    Если глобальный предикат является дизъюнкцией локальных, то его
    предельно просто проверять даже без построения каких-либо срезов.
\end{remark}

\begin{definition}
    Предикат называется \textit{слабым конъюнктивным}, если он верен
    тогда и только тогда, когда он верен на хотя бы одном согласованном срезе.
\end{definition}

\begin{theorem}
    Срез согласован тогда и только тогда, когда векторные времена процессов
    на этом срезе попарно несравнимы.
\end{theorem}

\begin{algorithm}(Централизованный алгоритм для слабого конъюнктивного предиката)
    \enewline
    \begin{itemize}
        \item Каждый процесс отслеживает свое векторное время $VC$.
        \item При наступлении истинности локального предиката,
            отправляем сообщение координатору C (делая при этом все
            необходимые манипуляции со временем).
        \item Координатор поддерживает \textit{срез-кандидат} и
            очередь необработанных сообщений.
            \begin{itemize}
                \item Для каждой компоненты среза-кандидата координатор хранит
                    флажок. Красный -- элемент не может быть частью согласованного
                    среза. Зеленый -- может. Начальное состояние -- нулевой вектор,
                    все флажки красные.
                \item Обрабатываем сообщения только от красных процессов; от зеленых
                    сообщения идут в очередь.
                \item Сравниваем пришедший вектор попарно с другими процессами
                    (достаточно сравнить только две соответствующие компоненты).
                    Если нарушилась согласованность (новый вектор оказался больше),
                    то делаем меньший процесс красным. После обработки делаем
                    процесс зеленым.
                \item Как только все флажки стали зелеными, найден согласованный срез.
            \end{itemize}
    \end{itemize}
\end{algorithm}

\begin{theorem}(Корректность)
    \enewline
    \begin{itemize}
        \item Алгоритм никогда не пропустит согласованный срез. Действительно,
            пусть есть согласованный срез. В каком-то порядке процессы дойдут
            то момента истинности предиката, после чего пошлют сообщения координатору.
            Ни одно из этих сообщений не может сделать другой процесс красным
            (если он стал зеленым после обработки сообщения их этого среза),
            потому что срез согласован. Поэтому все процессы станут зелеными
            сразу после обработки соответствующих сообщений.
        \item Компонента согласованного среза становится зеленой
            и всгеда будет такой оставаться.
    \end{itemize}
\end{theorem}

