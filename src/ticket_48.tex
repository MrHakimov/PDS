\section{MapReduce. Распределенная реализация. Мапперы и редьюсеры, локальность
  map, сбои узлов, избыточность.}

\begin{algorithm}
  \textit{Распределенная реализация}.
  \begin{itemize}
    \item $M$ \textit{узлов-мапперов} параллельно выполняют операцию
      \texttt{map} для разных документов.
    \item $R$ \textit{узлов-редьюсеров} параллельно выполняют операцию
      \texttt{reduce} для разных ключей. При этом все значения,
      соответствующие одному ключу, должны обрабатываться на одном узле
      (напр. \texttt{hash(key) \% R}).
    \item Один узел является \textit{мастером} и координирует работу всех
      узлов.
  \end{itemize}
\end{algorithm}

\begin{definition}
  \textit{Узел-маппер в распределенной реализации}.
  \begin{itemize}
    \item Каждый узел хранит в памяти $R$ корзин пар ключ-значение, каждая из
      которых впоследствии попадает на свой определенный редьюсер.
    \item При переполнении памяти корзины сбрасываются с оперативной памяти на
      диск, в отдельный файл.
    \item \textit{Мастер} с определенной периодичностью уведомляет мастер о
      статусе выполнения задачи.
  \end{itemize}
\end{definition}

\begin{definition}
  \textit{Узел-редьюсер в распределенной реализации}.
  \begin{itemize}
    \item Узлы читают предназначенные им корзины с маппров до тех пор, пока не
      будут собраны все значения.
    \item Сортирует и группирует собранные данные по ключу.
    \item Вызывает \texttt{reduce} на собранных значениях и записывает результат
      в итоговый файл.
  \end{itemize}
\end{definition}

\textbf{Обраотка сбоев мапперов.}
\begin{itemize}
  \item Сбой маппера определяется утратой сообщений о статусе выполнения задачи.
  \item Если узел передал все корзины соответствующим редьюсерам, то его задачу
    можно не перезапускать.
  \item Если какой-либо редьюсер не получил с упавшего маппера хотя бы одну
    корзину, задача перезапускается на новом узле, а полученные раннее корзины
    от старого узла инвалидируются (т.к. алгоритм маппера может быть
    недетерминированным).
  \item  \textbf{Замечание от автора.} Если после сбоя маппера, отправившего все
    корзины, также дал сбой редьюсер, задачу также придется перезапустить на
    другом узле, т.к. новому узлу-редьюсеру заново потребуются утраченные
    корзины. С другой стороны, корзины можно реплицировать.
\end{itemize}

\textbf{Обраотка сбоев редьюсеров.}
\begin{itemize}
  \item Сбой редьюсера определяется пингом.
  \item При сбое редьюсера до завершения свертки и репликации результирующего
    файла, задача полностью перезапускается на другом узле. При этом потребуется
    заново собрать данные с соответствующих корзин на каждом маппере.
  \item В противном случае, перезапуск задачи не требуется
\end{itemize}

\textbf{Обраотка сбоев мастера.}
\begin{itemize}
  \item Мастер может с определенной периодичностью делать снимки состояния
    задачи: статус подзадач map и reduce, местоположение файлов с результатами
    и др.
  \item Используя информацию со снимков, можно перезапускать задачу,
    не повторяя уже выполненных вычислений.
\end{itemize}

\textbf{Оптимизация: локальность map.}
\begin{itemize}
  \item По возможности следует запускать \texttt{map} на узлах, где
    непосредственно расположен документ для сокращения нагрузки на сеть. Так как
    файлы реплицируются, для каждого документа будет несколько кандидатов.
  \item Если все кандидаты заняты, следует отдать предпочтение узлам,
    расположенным как можно ближе к тем, на которых расположены реплики
    документов. Это требуется для максимального ускорения передачи файлов.
\end{itemize}

\textbf{Оптимизация: избыточность.}
\begin{itemize}
  \item Любую подзадачу можно запускать как гонку на нескольких узлах
    одновременно, т.е. взять результат из узла, который завершит выполнение
    раньше.
  \item Гонку следует запускать на медленных узлах, так медленные задачи не
    будут тормозить весь процесс.
  \item При завершении $\approx 95\%$ задач, можно запустить гонку по
    оставшимся, поскольку это будут самые медленные задачи, задерживающие
    выполнение задачи в целом.
\end{itemize}
