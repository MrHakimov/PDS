\section{Multi-Leader репликация: векторные версии, объединение версий. Разрешение конфликтов при чтении и записи, параллельное разрешение конфликтов, изменение состава кластера.}

\begin{algorithm}(Векторные версии)
    \begin{itemize}
        \item Храним на каждой реплике key-value базу данных.
        \item На каждой реплике для каждой записи ключ-значение храним вектор версий.
        \item Реплики обмениваются локальными значениями вместе с версиями.
        \item $k$-ая компонента вектора показывает, сколько обновлений этого ключа мы видели с реплики $k$.
        \item При изменении значения увеличиваем локальную компоненту вектора на 1.
        \item Если $A$ \textit{happens-before} $B$, то $A$ может быть удалена.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Параллельные обновления)
    \begin{itemize}
        \item Параллельность определяется так же, как и в векторных часах.
        \item Мы сами не можем определить, какое значение правильное (так как нет \textit{happens-before}), тогда сохраним оба значения и пусть приложение само решит, что делать.
        \item Новая версия -- покомпонентный максимум из двух несравнимых векторов.
    \end{itemize}
\end{algorithm}

\begin{remark}
    Приложение может само решать конфликты. Пример: объединение множеств, так элементы не будут потеряны, но могут остаться удаленные.
\end{remark}

\begin{remark}
    Некоторые конфликты невозможно разрешить на уровне приложения. Например, запись числа в поле объекта.
\end{remark}

\begin{algorithm}(Разрешение конфликтов при чтении)
    \begin{itemize}
        \item Приложение читает данные и понимает, что версии разошлись.
        \item Решает конфликт, получает итоговое значение.
        \item Записывает его в базу.
        \item Увеличивая локальную версию той реплики, куда новая версия будет записана.
        \item Результирующему значению будут предшествовать все конфликтующие записи.
        \item Результирующее значение заменит любое из них.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Разрешение конфликтов при чтении на разных узлах)
    \begin{itemize}
        \item Конфликт может быть одновременно решен на нескольких узнал, но тогда получаем несравнимые вектора.
        \item Вероятность такого мала, так как конфликт решается при чтении клиентом.
        \item Используем детерменированное разрешение конфликтов.
        \item Как обычно, либо можем сохранить два значение и дать приложению решить конфликт.
        \item Вероятность такого конфликта мала, так как конфликт решается приложением при чтении,
            то нужно чтобы с двух разных узлов два приложения параллельно прочитали конфликтные значения, решили этот конфликт и сделали параллельную запись на два разных узла.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Разрешение конфликтов при записи)
    \begin{itemize}
        \item Есть конфликты, которые сама реплика может решить при получении конфликтующей версии.
        \item Обычно так решаются очень простые конфликты, которые не требуют вмешательства сложной логики на стороне приложения.
        \item Например, параллельная запись в разные поля объекта.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Изменение состава кластера)
    \begin{itemize}
        \item Вместо вектора будем хранить отображение.
        \item Ключ -- имя узла. Значение -- версия, которая была увидена с узла.
        \item Если же в отображении нет нужного нам ключа, то представим, что он там есть, и значение $0$.
    \end{itemize}
\end{algorithm}

\begin{algorithm}(Удаление старых версий)
    \begin{itemize}
        \item Мотивация: векторные часы при увеличении количества реплик увеличиваются в размерах.
        \item Хотим удалять старые значения, которые соответствуют выведенным из эксплуатации узлам.
        \item Будем на каждом из узлов помнить, когда мы получали в последний раз сообщение от каждой из реплик.
        \item Из векторных часов можно удалить ключ, который соответствует реплике,
            от которой дольше всего не было сообщений, так как с наибольшей вероятностью эта реплика уже не существует.
        \item Есть возможность потерять отношение \textit{happens-before}.
    \end{itemize}
\end{algorithm}
